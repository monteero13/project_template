---
title: "Untitled"
author: "Alexandra"
date: "2024-11-28"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Clustering Basado en centralidad de intermediación de enlaces
```{r cars}
library(igraph)

# Leer la red desde un archivo TSV 
network_file <- "string_interactions_short.tsv"
edges <- read.table(network_file, header = TRUE, sep = "\t")

# Crear el grafo desde el TSV
if ("weight" %in% colnames(edges)) {
  g <- graph_from_data_frame(edges, directed = FALSE)
  E(g)$weight <- edges$weight
} else {
  g <- graph_from_data_frame(edges, directed = FALSE)
}

# Calcular la betweenness de las aristas
edge_btw <- edge_betweenness(g)
top_edges <- order(edge_btw, decreasing = TRUE)

# Configuración del layout para graficar
layout <- layout_with_fr(g)  # Fruchterman-Reingold layout

# Graficar la red original con las aristas de mayor betweenness resaltadas
plot(g, layout = layout, main = "Red Original con Aristas de Alta Betweenness",
     edge.width = ifelse(rank(-edge_btw) <= 1, 4, 1),  # Resalta la arista con mayor betweenness
     edge.color = ifelse(rank(-edge_btw) <= 1, "red", "gray"),
     vertex.color = "skyblue", vertex.size = 10, vertex.label = NA)

# Remover aristas con mayor betweenness iterativamente y graficar
edge_to_remove <- which.max(edge_btw)
for (i in 1:20) {
  cat("Quitando enlace con la ", i, " mayor betweenness\n")
  
  # Remover la arista con mayor betweenness
  g <- delete_edges(g, E(g)[edge_to_remove])
  
  # Recalcular los componentes conectados
  components <- clusters(g)
  
  # Calcular y mostrar la modularidad
  mod <- modularity(g, components$membership)
  
  # Asignar colores a los componentes
  component_colors <- rainbow(components$no)[components$membership]
  
  # Recalcular betweenness para el siguiente paso
  edge_btw <- edge_betweenness(g)
  edge_to_remove <- which.max(edge_btw)
  
  # Graficar el grafo actualizado
  plot(g, layout = layout, main = paste("Después de quitar la ", i, " mayor betweenness\n Modularity =", mod, "\n Clusters:", components$no),
       vertex.color = component_colors, vertex.size = 10, vertex.label = NA,
       edge.width = ifelse(rank(-edge_btw) <= 1, 4, 1),  # Resalta la siguiente arista con mayor betweenness
       edge.color = ifelse(rank(-edge_btw) <= 1, "red", "gray"), edge.width = 1)
}
```

# Clustering Basado en Walktrap
```{r cars2}
library(igraph)

# Leer la red desde un archivo TSV
network_file <- "string_interactions_short.tsv"
edges <- read.table(network_file, header = TRUE, sep = "\t")

# Crear el grafo desde el archivo TSV
if ("weight" %in% colnames(edges)) {
  g <- graph_from_data_frame(edges, directed = FALSE)
  E(g)$weight <- edges$weight  # Si hay una columna "weight", asignarla
} else {
  g <- graph_from_data_frame(edges, directed = FALSE)
}

# Aplicar Walktrap clustering
wc <- cluster_walktrap(g)

# Visualizar las comunidades detectadas
plot(
  g,
  vertex.color = membership(wc),
  vertex.size = 5,
  layout = layout_with_fr(g),
  edge.arrow.size = 0.5,
  main = "Clustering basado en Walktrap"
)

# Evaluar modularidad
modularity(wc)

# Visualizar la progresión de Walktrap (seleccionar algunos pasos clave)
plot_walktrap_progression <- function(graph, walktrap, step) {
  memberships <- cut_at(walktrap, no = step)  # Membresías de los nodos en este paso
  node_colors <- rainbow(max(memberships))[memberships]  # Colorear los nodos por comunidad
  
  plot(graph, 
       vertex.color = node_colors, 
       vertex.label = NA, 
       main = paste("Step", length(walktrap$merges) - step + 1, 
                    "-", step, "Clusters"),
       layout = layout_with_fr)
}

# Visualizar los pasos clave de la progresión de Walktrap
for (step in c(1, 2, 3, 4)) {  # Seleccionar pasos clave para ilustrar la progresión
  plot_walktrap_progression(g, wc, step)
}

# Visualizar el dendrograma
par(mfrow = c(1, 1))
plot_dendrogram(wc, main = "Walktrap Dendrogram")
```